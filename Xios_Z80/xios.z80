            TITLE  'MP/M-II Banked XIOS for RCBus'
            ; Get processor, chip and general equates
            .z80

;******************************************************************************
;******************************************************************************
;**                                                                          **
;**                   M P / M   I I   X I O S   M o d u l e                  **
;**                              by Tadeusz Pycio                            **
;**                                                                          **
;******************************************************************************
;******************************************************************************
;  Build:   ZSM XIOS,XIOS=XIOS.Z80
;           LINK BNKXIOS=XIOS[NR,OS]
;
;  Revision History:                                                           
;  Rev    Date         Author                Comments                          
;  0.80   22-09-2021   Tadeusz Pycio         Created                           
;  0.91   20-07-2023   Tadeusz Pycio         SIO Interrupt handler             
;  1.00   30-12-2023   Tadeusz Pycio         Commonbase address offset         
;  1.02   19-01-2023   Tadeusz Pycio         Add support MMU 74HCT612          
;******************************************************************************

false       equ   0
true        equ   not false

quecon      equ   true              ; true if using queued consoles
rc2014      equ   false             ; RC2014 | Zilog SIO address scheme
mmu612      equ   false             ; MMU 74612| MMU Z2

tpabuf      equ   80h               ; Default I/O buffer and command line storage
cbase       equ   0C0h              ; CommonBase address
numbnk      equ   7                 ; number of memory banks
numdsk      equ   16                ; number disks
numcns      equ   2                 ; number of consoles

vect        equ   6                 ; restart vector number

; Ascii Character Equates
LF          equ   0Ah               ; Line Feed
CR          equ   0Dh               ; Carriage Return

; Hardware definitions
IDE         EQU   010h              ; address interface IDE CF
MMU         equ   078h              ; base address MMU Z2
SIO         equ   080h              ; base address SIO
CTC         equ   088h              ; base address CTC

      if  rc2014
; Z80 SIO addresses used by RC2014 official module
SIOA_D      equ   SIO+1             ; Serial port A Data
SIOA_C      equ   SIO               ; Serial port A Control
SIOB_D      equ   SIO+3             ; Serial port B Data
SIOB_C      equ   SIO+2             ; Serial port B Control
      else
; Z80 SIO addresses used by Zilog
SIOA_D      equ   SIO               ; Serial port A Data
SIOA_C      equ   SIO+2             ; Serial port A Control
SIOB_D      equ   SIO+1             ; Serial port B Data
SIOB_C      equ   SIO+3             ; Serial port B Control
      endif
; WR0:
RESCHN      equ   018h              ; Reset channel
RESSTA      equ   010h              ; Reset ext/status
RESERR      equ   030h              ; Error reset
; WR5:
DTROFF      equ   068h          ; DTR off, Tx 8 bits, Tx enable, RTS off
DTRON       equ   0EAh              ; DTR on, Tx 8 bits, Tx enable, RTS on 
; RR0:
DAV         equ   0                 ; Data available
TBMT        equ   2                 ; Transmit buffer empty
DCD         equ   3                 ; Data carrier detect 
; RR1:
OE          equ   020h              ; Overrun error
FE          equ   040h              ; Framing error
ERR         equ   OE+FE             ; Overrun and framing errors
; CF registers
CF_DATA     equ   IDE
CF_FEATURES equ   IDE+1
CF_ERROR    equ   IDE+1
CF_SECCOUNT equ   IDE+2
CF_SECTOR   equ   IDE+3
CF_CYL_LOW  equ   IDE+4
CF_CYL_HI   equ   IDE+5
CF_HEAD     equ   IDE+6
CF_STATUS   equ   IDE+7
CF_COMMAND  equ   IDE+7
CF_LBA0     equ   IDE+3
CF_LBA1     equ   IDE+4
CF_LBA2     equ   IDE+5
CF_LBA3     equ   IDE+6
;CF Features
CF_8BIT     equ   1
CF_NOCACHE  equ   082h
;CF Commands
CF_RD_SEC   equ   020h
CF_WR_SEC   equ   030h
CF_SET_FEAT equ   0EFh

; -----------------------------------------------------------------------------
            cseg
base        equ    $
; Jump vectors for individual subroutines

XIOS:       jp    commonbase        ; CommonBase, Terminate process
wboot:      jp    warmstart         ; Warm Boot, Terminate process
            jp    const             ; Check for console char ready
            jp    conin             ; Read console character in
            jp    conout            ; Write console character out
            jp    list              ; Write list character out
            jp    rtnempty          ; not used by MP/M II
            jp    rtnempty          ; not used by MP/M II
            jp    home              ; Move to track 00
            jp    seldsk            ; Select disk drive
            jp    settrk            ; Set track number
            jp    setsec            ; Set sector number
            jp    setDMA            ; Set DMA address
            jp    read              ; Read selected sector
            jp    write             ; Write selected sector
            jp    rtnempty          ; not used by MP/M II
            jp    sectran           ; Sector translate subroutine

            jp    selmemory         ; Select memory
            jp    polldevice        ; Poll device
            jp    startclock        ; Start clock
            jp    stopclock         ; Stop clock
            jp    exitregion        ; Exit critical region
            jp    maxconsole        ; Maximum console number
            jp    systeminit        ; System initialization
            db    0,0,0             ; force use of internal dispatch @ idle
;           jp    idle

; -----------------------------------------------------------------------------

blksiz      equ   4096              ;MP/M allocation size
hstsiz      equ   512               ;host disk sector size
hstspt      equ   32                ;host disk sectors/trk
hstblk      equ   hstsiz/128        ;MP/M sects/host buff
cpmspt      equ   hstblk * hstspt   ;MP/M sectors/track
secmsk      equ   hstblk-1          ;sector mask

wrall       equ   0                 ; write to allocated
wrdir       equ   1                 ; write to directory
wrual       equ   2                 ; write to unallocated

; -----------------------------------------------------------------------------
home:       ld    a,(hstwrt)    ; check for pending write
            or    a
            jr    nz,homed
            ld    (hstact),a    ; clear host active flag
homed:      ld    bc,0000h
; -----------------------------------------------------------------------------
settrk:     ld    (sektrk),bc   ; Set track passed from BDOS in register BC.
            ret
; -----------------------------------------------------------------------------
; Save Sector Number Passed in Reg C.

setsec:     ld    (seksec),bc   ; Set sector passed from BDOS in register BC.
            ret
; -----------------------------------------------------------------------------
; Translate Sector (BC), using table at (DE)

sectran:    ld    h,b
            ld    l,c               ; Null routine: just BC => HL
            ret
; -----------------------------------------------------------------------------
; Set DMA address given by registers bc
setdma:     ld    (dmaadr),bc   ; Buffer addr. in BC
            inc   bc                ; check for flush buffer
            ld    a,b               ; check for b,c = 0
            or    c
            ret   nz                ; hl=FFFF is flush buffer
            ld    hl,hstwrt         ; point to host write flag
            ld    a,(hl)            ; check for pending write
            ld    (hl),0            ; reset, we are writing it out
            or    a                 ; is it pending write?
            ret   z                 ; return if not
            call  writehst          ; else,..flush to disk
            or    a                 ; any errors?
            ret   z                 ; return if not
            pop   hl                ; error found
            ret
; -----------------------------------------------------------------------------
seldsk:     ld    hl,0000h      ; Select drive (C): DPH ptr. in HL
            ld    a,c
            cp    numdsk            ; 16 for 128MB disk
            jr    c,chgdsk      ; if invalid drive will give BDOS error
            ld    a,(userdrv)   ; so set the drive back to a:
            cp    c             ; If the default disk is not the same as the
            ret   nz            ; selected drive then return, 
            xor   a             ; else reset default back to a:
            ld    (userdrv),a   ; otherwise will be stuck in a loop
            ld    (sekdsk),a
            ret
; -----------------------------------------------------------------------------
chgdsk:     ld    (sekdsk),a
            rlc   a                 ;*2
            rlc   a                 ;*4
            rlc   a                 ;*8
            rlc   a                 ;*16
            ld    hl,dpbase
            ld    b,0
            ld    c,a
            add   hl,bc             ; hl is the new DPB address
            ret
;------------------------------------------------------------------------------
            ;read the selected MP/M sector
; Deblock read routine
read:       xor   a
            ld    (unacnt),a        ;unacnt = 0
            inc   a
            ld    (readop),a        ;read operation
            ld    (rsflag),a        ;must read data
            ld    a,wrual
            ld    (wrtype),a        ;treat as unalloc
            jr    rwoper            ;to perform the read
;------------------------------------------------------------------------------
            ;write the selected MP/M sector
; Deblock write routine
write:      xor   a                 ;0 to accumulator
            ld    (readop),a    ;not a read operation
            ld    a,c           ;write type in c
            ld    (wrtype),a
            cp    wrual         ;write unallocated?
            jr    nz,chkuna     ;check for unalloc

            ;write to unallocated, set parameters
            ld    a,blksiz/128  ;next unalloc recs
            ld    (unacnt),a
            ld    a,(sekdsk)    ;disk to seek
            ld    (unadsk),a    ;unadsk = sekdsk
            ld    hl,(sektrk)
            ld    (unatrk),hl   ;unatrk = sectrk
            ld    a,(seksec)
            ld    (unasec),a    ;unasec = seksec
;
            ;check for write to unallocated sector
chkuna:     ld    a,(unacnt)    ;any unalloc remain?
            or    a
            jr    z,alloc       ;skip if not
;
            ;more unallocated records remain
            dec   a             ;unacnt = unacnt-1
            ld    (unacnt),a
            ld    a,(sekdsk)    ;same disk?
            ld    hl,unadsk
            cp    (hl)          ;sekdsk = unadsk?
            jr    nz,alloc          ;skip if not
;
            ;disks are the same
            ld    hl,unatrk
            call  sektrkcmp     ;sektrk = unatrk?
            jr    nz,alloc         ;skip if not
;
            ;tracks are the same
            ld    a,(seksec)    ;same sector?
            ld    hl,unasec
            cp    (hl)          ;seksec = unasec?
            jr    nz,alloc          ;skip if not
;
            ;match, move to next sector for future ref
            inc   (hl)          ;unasec = unasec+1
            ld    a,(hl)        ; end of track?
            cp    cpmspt        ;count CP/M sectors
            jr    c,noovf       ;skip if no overflow
;
            ;overflow to next track
            ld    (hl),0        ;unasec = 0
            ld    hl,(unatrk)
            inc   hl
            ld    (unatrk),hl   ;unatrk = unatrk+1
;
            ;match found, mark as unnecessary read
noovf:      xor   a             ;0 to accumulator
            ld    (rsflag),a    ;rsflag = 0
            jr    rwoper        ;to perform the write
;
            ;not an unallocated record, requires pre-read
alloc:      xor   a             ;0 to accum
            ld    (unacnt),a    ;unacnt = 0
            inc   a             ;1 to accum
            ld    (rsflag),a    ;rsflag = 1

;------------------------------------------------------------------------------
;           enter here to perform the read/write
rwoper:     xor   a             ;zero to accum
            ld    (erflag),a    ;no errors (yet)
            ld    a,(seksec)    ;compute host sector
            or    a             ;carry = 0
            rra                 ;shift right
            or    a             ;carry = 0
            rra                 ;shift right
            ld    (sekhst),a    ;host sector to seek
;
            ;active host sector?
            ld    hl,hstact     ;host active flag
            ld    a,(hl)
            ld    (hl),1        ;always becomes 1
            or    a             ;was it already?
            jr    z,filhst      ; fill host if not
;
            ;host buffer active, same as seek buffer?
            ld    a,(sekdsk)
            ld    hl,hstdsk     ;same disk?
            cp    (hl)          ;sekdsk = hstdsk?
            jr    nz,nomatch
;
            ;same disk, same track?
            ld    hl,hsttrk
            call  sektrkcmp     ;sektrk = hsttrk?
            jr    nz,nomatch
;
            ;same disk, same track, same buffer?
            ld    a,(sekhst)
            ld    hl,hstsec     ;sekhst = hstsec?
            cp    (hl)
            jr    z,match       ;skip if match
            ;proper disk, but not correct sector
nomatch:    ld    a,(hstwrt)    ;host written?
            or    a
            call  nz,writehst   ;clear host buff
            ;may have to fill the host buffer
filhst:     ld    a,(sekdsk)
            ld    (hstdsk),a
            ld    hl,(sektrk)
            ld    (hsttrk),hl
            ld    a,(sekhst)
            ld    (hstsec),a
            ld    a,(rsflag)    ;need to read?
            or    a
            call  nz,readhst    ;yes, if 1
            xor   a             ;0 to accum
            ld    (hstwrt),a    ;no pending write
            ;copy data to/from buffer
match:      ld    a,(seksec)        ;mask buffer number
            and   secmsk        ;least signif bits
            ld    h,a
            ld    l,0
            srl   h
            rr    l                 ;HL = L << 7
            ;hl has relative host buffer address
            ld    de,hstbuf
            add   hl,de         ;hl = host address
            ld    de,(dmaadr)   ;get/put MP/M data
            ld    a,(readop)    ;which way?
            or    a
            jp    nz,rwmove     ;skip if read
;
            ;write operation, mark and switch direction
            ld    a,1
            ld    (hstwrt),a    ;hstwrt = 1
            ex    de,hl         ;source/dest swap
            jp    rwmove

;------------------------------------------------------------------------------
;Utility subroutine for 16-bit compare
sektrkcmp:
            ;HL = .unatrk or .hsttrk, compare with sektrk
            ex    de,hl
            ld    hl,sektrk
            ld    a,(de)        ;low byte compare
            cp    (hl)          ;same?
            ret   nz            ;return if not
                                ;low bytes equal, test high 1s
            inc   de
            inc   hl
            ld    a,(de)
            cp    (hl)          ;sets flags
            ret

;------------------------------------------------------------------------------
; Read physical sector from host

readhst:    call  cfWait
            call  SetLBAadr

            ld    a,CF_RD_SEC
            out   (CF_COMMAND),a

            call  cfWait
            ld    hl,hstbuf
            ld    bc,CF_DATA            
            inir                ; input 256 bytes
            inir                ; and another 256

            xor   a
            ld    (erflag),a
            ret

;------------------------------------------------------------------------------
; Write physical sector to host

writehst:   call  cfWait
            call  SetLBAadr

            ld    a,CF_WR_SEC
            out   (CF_COMMAND),a

            call  cfWait
            ld    hl,hstbuf
            ld    bc,CF_DATA
            otir                ; output 256 bytes
            otir                ; and another 256

            xor   a
            ld    (erflag),a
            ret

;------------------------------------------------------------------------------
; Convert track/head/sector into LBA for physical access to the disk
; 00Vvvvvv|vvTttttt|tttsssss   some serious bitshifting ahead
; code by Rienk H. Koolstra

SetLBAadr:  ld    hl,(hsttrk)   ; 0000000T tttttttt
            ld    a,l           ; tttttttt
            and   07h           ; 00000ttt
            rrca                ; t00000tt
            rrca                ; tt00000t
            rrca                ; ttt00000
            ld    b,a
            ld    a,(hstsec)    ; 000sssss
            or    b             ; tttsssss
            out   (CF_LBA0),a

            ld    a,l           ; tttttttt
            and   0F8h          ; ttttt000
            or    h             ; ttttt00T
            rrca                ; Tttttt00
            rrca                ; 0Tttttt0
            rrca                ; 00Tttttt
            ld    b,a
            ld    a,(hstdsk)    ; Vvvvvvvv (V is used for the 128+ diskset)
            rrca                ; vVvvvvvv
            rrca                ; vvVvvvvv
            ld    c,a
            and   0C0h          ; vv000000
            or    b             ; vvTttttt
            out   (CF_LBA1),a

            ld    a,c           ; vvVvvvvv
            and   3Fh           ; 00Vvvvvv
            out   (CF_LBA2),a
            ld    a,0E0h            ; LBA Mode using drive 0 = E0
            out   (CF_LBA3),a

            ld    a,1
            out   (CF_SECCOUNT),a

            ret

; -----------------------------------------------------------------------------

sekdsk:     ds    1             ;seek disk number
sektrk:     ds    2             ;seek track number
seksec:     ds    2             ;seek sector number
;
hstdsk:     ds    1             ;host disk number
hsttrk:     ds    2             ;host track number
hstsec:     ds    1             ;host sector number
;
sekhst:     ds    1             ;seek shr secshf
hstact:     ds    1             ;host active flag
hstwrt:     ds    1             ;host written flag
;
unacnt:     ds    1             ;unalloc rec cnt
unadsk:     ds    1             ;last unalloc disk
unatrk:     ds    2             ;last unalloc track
unasec:     ds    1             ;last unalloc sector
;
erflag:     ds    1             ;error reporting
rsflag:     ds    1             ;read sector flag
readop:     ds    1             ;1 if read operation
wrtype:     ds    1             ;write operation type
dmaadr:     ds    2             ;last dma address

alv00:      ds    257           ;allocation vector 0
alv01:      ds    257           ;allocation vector 1
alv02:      ds    257           ;allocation vector 2
alv03:      ds    257           ;allocation vector 3
alv04:      ds    257           ;allocation vector 4
alv05:      ds    257           ;allocation vector 5
alv06:      ds    257           ;allocation vector 6
alv07:      ds    257           ;allocation vector 7
alv08:      ds    257           ;allocation vector 8
alv09:      ds    257           ;allocation vector 9
alv10:      ds    257           ;allocation vector 10
alv11:      ds    257           ;allocation vector 11
alv12:      ds    257           ;allocation vector 12
alv13:      ds    257           ;allocation vector 13
alv14:      ds    257           ;allocation vector 14
alv15:      ds    257           ;allocation vector 15

temp:                           ;systeminit workspace

hstbuf:     ds    512           ;host buffer

;==============================================================================
commonbase: jp    coldstart
swtuser:    jp    $-$
swtsys:     jp    $-$
pdisp:      jp    $-$
xdos:       jp    $-$
sysdat:     dw    $-$
;==============================================================================
; Padding to make sure that the Z80 interrupt table begins on an 32-byte boundary
padding     equ   (($+0Fh) and 0FFE0h) - $
; ZSM4 generates an error here which should be ignored.
            ds    padding

itbl:       dw    badint               ; CTC channel 0
            dw    badint               ; CTC channel 1
            dw    timerint             ; CTC channel 2
            dw    badint               ; CTC channel 3
            dw    serialint            ; SIO receive a character
            dw    badint               ; SIO receiver buffer overrun
; -----------------------------------------------------------------------------
coldstart:
warmstart:  ld    c,0
            jp    xdos        ; system reset, terminate process

; -----------------------------------------------------------------------------
; Disk parameter headers for disk 0 to 15
; -----------------------------------------------------------------------------

dpbase:     dw    0000h,0000h,0000h,0000h,dirbuf,dpb0,0000h,alv00
            dw    0000h,0000h,0000h,0000h,dirbuf,dpb,0000h,alv01
            dw    0000h,0000h,0000h,0000h,dirbuf,dpb,0000h,alv02
            dw    0000h,0000h,0000h,0000h,dirbuf,dpb,0000h,alv03
            dw    0000h,0000h,0000h,0000h,dirbuf,dpb,0000h,alv04
            dw    0000h,0000h,0000h,0000h,dirbuf,dpb,0000h,alv05
            dw    0000h,0000h,0000h,0000h,dirbuf,dpb,0000h,alv06
            dw    0000h,0000h,0000h,0000h,dirbuf,dpb,0000h,alv07
            dw    0000h,0000h,0000h,0000h,dirbuf,dpb,0000h,alv08
            dw    0000h,0000h,0000h,0000h,dirbuf,dpb,0000h,alv09
            dw    0000h,0000h,0000h,0000h,dirbuf,dpb,0000h,alv10
            dw    0000h,0000h,0000h,0000h,dirbuf,dpb,0000h,alv11
            dw    0000h,0000h,0000h,0000h,dirbuf,dpb,0000h,alv12
            dw    0000h,0000h,0000h,0000h,dirbuf,dpb,0000h,alv13
            dw    0000h,0000h,0000h,0000h,dirbuf,dpb,0000h,alv14
            dw    0000h,0000h,0000h,0000h,dirbuf,dpbLast,0000h,alv15

; First drive has a reserved track for MP/M

dpb0:       dw    128               ;SPT - sectors per track
            db    5                 ;BSH - block shift factor
            db    31                ;BLM - block mask
            db    1                 ;EXM - Extent mask
            dw    2043              ; (2047-4) DSM - Storage size (blocks - 1)
            dw    511               ;DRM - Number of directory entries - 1
            db    240               ;AL0 - 1 bit set per directory block
            db    0                 ;AL1 -            "
            dw    0                 ;CKS - DIR check vector size (DRM+1)/4 (0=fixed disk)
            dw    1                 ;OFF - Reserved tracks

dpb:        dw    128               ;SPT - sectors per track
            db    5                 ;BSH - block shift factor
            db    31                ;BLM - block mask
            db    1                 ;EXM - Extent mask
            dw    2047              ;DSM - Storage size (blocks - 1)
            dw    511               ;DRM - Number of directory entries - 1
            db    240               ;AL0 - 1 bit set per directory block
            db    0                 ;AL1 -            "
            dw    0                 ;CKS - DIR check vector size (DRM+1)/4 (0=fixed disk)
            dw    0                 ;OFF - Reserved tracks

; Last drive is smaller because CF is never full 128MB
dpbLast:    dw    128               ;SPT - sectors per track
            db    5                 ;BSH - block shift factor
            db    31                ;BLM - block mask
            db    1                 ;EXM - Extent mask
            dw    511               ;DSM - Storage size (blocks - 1)  ; 511 = 2MB (for 128MB card)
            dw    511               ;DRM - Number of directory entries - 1
            db    240               ;AL0 - 1 bit set per directory block
            db    0                 ;AL1 -            "
            dw    0                 ;CKS - DIR check vector size (DRM+1)/4 (0=fixed disk)
            dw    0                 ;OFF - Reserved tracks

;------------------------------------------------------------------------------
; Read/write move routine.
            ;BC initially 128, HL is source, DE is dest
rwmove:     push  de
            push  hl

            call  swtuser           ;switch to user context
            di                      ;disable int
            pop   hl
            pop   de
            ld    bc, 128           ;length of move 
;            ldir
transfer:   ldi
            ldi
            ldi
            ldi
            jp    v, transfer       ;more than 11% faster than ldir
            call  swtsys            ;back to system context
;
            ;data has been moved to/from host buffer
            ld    a,(wrtype)    ;write type
            cp    wrdir         ;to directory?
            ld    a,(erflag)    ;in case of errors
            ret   nz            ;no further processing
;
            ;clear host buffer for directory write
            or    a             ;errors?
            ret   nz            ;skip if so
            xor   a             ;0 to accum
            ld    (hstwrt),a    ;buffer written
            call  writehst
            ld    a,(erflag)
            ret

; -----------------------------------------------------------------------------
;	I / O   H A N D L E R S 

poll        equ   131               ; XDOS poll function
makeque     equ   134               ; XDOS make queue
readque     equ   137               ; XDOS read queue
writeque    equ   139               ; XDOS write queue
xdelay      equ   141               ; XDOS delay
create      equ   144               ; XDOS create process
flagwait    equ   132
flagset     equ   133
dsptch      equ   142


pldsk       equ   0                 ; poll CF 
plci0       equ   1                 ; poll console #0 input
plco0       equ   2                 ; poll console #0 output
plci1       equ   3                 ; poll console #1 input
plco1       equ   4                 ; poll console #1 output
;pllpt       equ   5                 ; poll LPT

            ; Console status
const:      call  ptbljmp           ; compute and jump to hndlr
            dw    con0st            ; console #0 status routine
            dw    con1st            ; console #1 status routine

            ; Read console character in
conin:      call  ptbljmp           ; compute and jump to hndlr
            dw    con0in            ; console #0 input
            dw    con1in            ; console #1 input

            ; Write console character out
conout:     call  ptbljmp           ; compute and jump to hndlr
            dw    con0out           ; console #0 output
            dw    con1out           ; console #1 output

ptbljmp:    ld    a,d               ; compute and jump to handler,
            cp    numcns            ; d = console #, preserve it
            jr    c,tbljmp
            pop   af                ; throw away table address
rtnempty:   xor   a
            ret
tbljmp:     add   a,a
            pop   hl
            ld    e,a
            ld    d,0
            add   hl,de
            ld    e,(hl)
            inc   hl
            ld    d,(hl)
            ex    de,hl
            jp    (hl)              ; jump to computed cns handler

; -----------------------------------------------------------------------------
; Reg C = device # to be polled
;       return 0ffh if ready, 000h if not
polldevice: ld    a,c
            cp    numdev
            jr    c,devok
            ld    a,numdev

devok:      call  tbljmp        ; jump to dev poll code

devtbl:     dw    poldsk
            dw    polci0
            dw    polco0
            dw    polci1
            dw    polco1

numdev      equ   ($-devtbl)/2
            dw    rtnempty

; -----------------------------------------------------------------------------
; Poll CF Disk
poldsk:     in    a,(CF_STATUS) ;Read status register 
            and   80h           ; A[7] (Busy)
            xor   80h
            ret   z
            ld    a,0FFh
            ret

;------------------------------------------------------------------------------
; Wait for disk to be ready (busy=0,ready=1)

cfWait:     in    a,(CF_STATUS)     ;Read status register
            bit   7,a           ;Test Busy flag
            jr    z, cfReady
                                ; High so busy
            ld    c,poll
            ld    e,pldsk
            call  xdos          ; poll CF disk

cfReady:    ret

; -----------------------------------------------------------------------------
;	C O N S O L E   0

;console #0 input routine
;
con0in      equ   $
      if  quecon
            ld    c,readque            ;read queue function
            ld    de,c0inuqcb          ;point to queue structure
            call  xdos                 ;call xdos for char
            ld    a,(char0in)          ;get char from buffer
            and   7fh                  ;strip parity
            ret

;Console #0 process descriptor
c0inpd      equ   $
            dw    c1inpd               ;pl
            db    0                    ;status
            db    32                   ;priority
            dw    c0instk+18           ;stack pointer
            db    'C0in    '           ;name of function
            db    0                    ;console
            db    0FFh                 ;memseg
            ds    36
c0instk:    dw    0c7c7h,0c7c7h,0c7c7h
            dw    0c7c7h,0c7c7h,0c7c7h
            dw    0c7c7h,0c7c7h,0c7c7h
            dw    c0inp                ;starting address

;Console #0 input queue
c0inq:      dw    0                    ;ql
            db    'C0inque '           ;name
            dw    1                    ;msglen
            dw    16                   ;nmbmsgs
            ds    8
c0inmsgcnt: ds    2                    ;message count
            ds    16                   ;buffer

c0inqcb:    dw    c0inq                ;pointer
            dw    ch0in                ;msg addr.
ch0in:      db    0

c0inuqcb:   dw    c0inq                ;pointer
            dw    char0in              ;msg addr.
char0in:    db    0                    ;char buffer
;
polci0      equ   $                    ;return ff if ready
con0st      equ   $                    ;else, 00 if not
            ld    a,(c0inmsgcnt)       ;any key pushed
            or    a                    ;check for a 0
            ret   z                    ;return if not ready
            ld    a,0FFh               ;else, return its ready
            ret
;
c0inp:      ld    c,makeque            ;make queue function
            ld    de,c0inq             ;point to queue
            call  xdos                 ;call xdos for makeing queue
c0loop:     ld    c,flagwait           ;set flagwait for char
            ld    e,6                  ;flag value
            call  xdos                 ;wait till co in intrp flag
            ld    c,writeque           ;now write the queue
            ld    de,c0inqcb           ;point to the buffer area
            call  xdos                 ;wait till char comes ready
            jp    c0loop               ;loop till it does.
;
      else
;
            ld    c,poll               ;poll function
            ld    e,plci0              ;chan 0 poll code
            call  xdos                 ; poll console #0 input
            in    a,(SIOA_D)
            and   7Fh
            ret

;console # 0 input status routine
;
polci0:     equ   $
con0st:     xor   a
            out   (SIOA_C),a           ; Select RR0
            in    a,(SIOA_C)           ; Read UART status register of COM port 0
            bit   DAV,a                ; Test character ready bit and loop
            ret   z
            ld    a,0FFh
            ret
      endif
;
;console # 0 output handler
;
con0out     call  polco0               ;use common status routine
            inc   a                    ;need service?
            jr    nz,tx0rdy            ;jump if so
            push  bc                   ;else, place on poll list
            ld    c,poll               ;poll function
            ld    e,plco0              ;device number to poll
            call  xdos                 ;poll console #0 output
            pop   bc                   ;recover char
tx0rdy:     ld    a,c                  ;get char
            out   (SIOA_D),a           ;send it
            ret
;
;console # 0 output status routine
;
polco0:     xor   a
            out   (SIOA_C),a           ; Select RR0
            in    a,(SIOA_C)           ; Read UART status register of COM port 0
            bit   TBMT, a              ; Test TX Data Register Empty ready bit
            ret   z
            ld    a,0FFh
            ret
; -----------------------------------------------------------------------------
;	C O N S O L E   1

;console #1 input routine
;
con1in      equ   $
      if  quecon
            ld    c,readque            ;read queue function
            ld    de,c1inuqcb          ;point to queue structure
            call  xdos                 ;call xdos for char
            ld    a,(char1in)          ;get char from buffer
            and   7fh                  ;strip parity
            ret
;Console #1 Process Descriptor
c1inpd      equ   $
            dw    0                    ;pl
            db    0                    ;status
            db    32                   ;priority
            dw    c1instk+18           ;stack pointer
            db    'C1in    '           ;name of function
            db    0                    ;console
            db    0FFh                 ;memseg
            ds    36
c1instk:    dw    0c7c7h,0c7c7h,0c7c7h
            dw    0c7c7h,0c7c7h,0c7c7h
            dw    0c7c7h,0c7c7h,0c7c7h
            dw    c1inp                ;starting address

c1inq:      dw    0                    ;ql
            db    'C1inque '           ;name
            dw    1                    ;msglen
            dw    16                   ;nmbmsgs
            ds    8
c1inmsgcnt:
            ds    2                    ;message count
            ds    16                   ;buffer
c1inqcb:    dw    c1inq                ;pointer
            dw    ch1in                ;msg addr.
ch1in:      db    0
c1inuqcb:
            dw    c1inq                ;pointer
            dw    char1in              ;msg addr.
char1in:    db    0                    ;char buffer
;
polci1      equ   $                    ;return ff if ready
con1st      equ   $                    ;else, 00 if not
            ld    a,(c1inmsgcnt)       ;any key pushed
            or    a                    ;check for a 0
            ret   z                    ;return if not ready
            ld    a,0FFh               ;else, return its ready
            ret
;
c1inp:      ld    c,makeque            ;make queue function
            ld    de,c1inq             ;point to queue
            call  xdos                 ;call xdos for makeing queue
c1loop:     ld    c,flagwait           ;set flagwait for char
            ld    e,7                  ;flag value
            call  xdos                 ;wait till co in intrp flag
            ld    c,writeque           ;now write the queue
            ld    de,c1inqcb           ;point to the buffer area
            call  xdos                 ;wait till char comes ready
            jp    c1loop               ;loop till it does.
;
      else
            ld    c,poll
            ld    e,plci1
            call  xdos                 ; poll console #1 input
            in    a,(SIOB_D)
            and   7Fh                  ; strip parity
            ret

;console # 1 input status routine
;
polci1:
con1st:     xor   a
            out   (SIOB_C),a           ;Select RR0
            in    a,(SIOB_C)           ;Read UART status register of COM port 1
            bit   DAV,a                ;Test character ready bit
            ret   z
            ld    a,0FFh
            ret
      endif
;
;console # 1 output handler
;
con1out:    xor   a
            out   (SIOB_C),a           ; Select RR0
            in    a,(SIOB_C)           ; Read UART status register of COM port 0
            bit   TBMT, a              ; Test TX Data Register Empty ready bit
            jr    nz,tx1rdy
            push  bc
            ld    c,poll
            ld    e,plco1
            call  xdos                 ; poll console #1 output
            pop   bc
tx1rdy:     ld    a,c
            out   (SIOB_D),a           ; send it
            ret

polco1:     xor   a
            out   (SIOB_C),a           ; Select RR0
            in    a,(SIOB_C)           ; Read UART status register of COM port 0
            bit   TBMT, a              ; Test TX Data Register Empty ready bit
            ret   z
            ld    a,0FFh
            ret

; -----------------------------------------------------------------------------
;	L I S T   D E V I C E  (in progress)

; List Device Status

;pollpt:
listst:     
;in0   a,(SPORT)     ; Get status
            rlca                ; A[7] (ready) -> CY
            sbc   a,a           ; A = -1 if CY set
            ret                 ; Returns A, & NZ if ready

; Output C on Printer
list:
lptout:     call  listst        ; Busy?
            jr    nz,lptrdy     ; Go if ready
;            push  bc
;            ld    c,poll
;            ld    e,pllpt
;            call  xdos
;            pop   bc
lptrdy:
;            out0  (DPORT),c     ; Latch data
            ld    a,0Dh
;            out0  (CPORT),a     ; STB = 1
            nop
            nop                 ; Pause
            ld    a,0Ch
;            out0  (CPORT),a     ; STB = 0
            ret

; -----------------------------------------------------------------------------
; Maximum Console Number
maxconsole: ld    a,numcns
            ret

; -----------------------------------------------------------------------------
;       B A N K   S W I T C H I N G
;    adr of mem descriptor = BC ----> base   1 byte,
selmemory:  inc   bc                ; size   1 byte,
            inc   bc                ; attrib 1 byte,
            inc   bc                ; bank   1 byte.
            ld    a,(bc)
selbank:    and   7                 ; bank number
            rlca
            rlca
      if  mmu612
            rlca
            rlca
            or    8Ch               ; bank or base addr + MMU page
            ld    c,7Ch             ; addr MMU 74612 + 0Ch
            ld    b,0Dh             ; number of changed registers
mmuloop:    out   (c),a
            dec   c
            dec   a
            djnz  mmuloop
            ret
      else
            or    20h               ; set A19
            out   (MMU),a           ; 0x0000-0x3FFF
            inc   a
            out   (MMU+1),a         ; 0x4000-0x7FFF
            inc   a
            out   (MMU+2),a         ; 0x8000-0xBFFF
            ret
      endif
;----------------------------------------------------------------
startclock: ld    a,0FFh            ; will cause flag #1 to be set
            ld    (tickn),a         ; at each system time unit tick
            ret
;----------------------------------------------------------------
stopclock:  xor   a                 ; will stop flag #1 setting at
            ld    (tickn),a         ; system time unit tick
            ret
;----------------------------------------------------------------
exitregion: ld    a,(preemp)
            or    a
            ret   nz
            ei                      ; EI if not preempted or in dispatcher
            ret

; -----------------------------------------------------------------------------
;	I N T E R R U P T   H A N D L E R S
;------------------------------------------------------------------------------
      if  quecon
serialint:  di
            push  af
            ld    (savsp),sp        ; save stack ptr
            ld    sp,lstintstk      ; local stack for intr hndl
            ld    (savhl),hl
            push  de
            push  bc
            push  ix
            push  iy
            ld    a,0FFh
            ld    (preemp),a
            ; Check if there is a char in channel A
            ; If not, there is a char in channel B
;            xor   a
;            out   (SIOA_C),a
            in    a,(SIOA_C)        ; Status byte D2=TX Buff Empty, D0=RX char ready
            rrca                    ; Rotates RX status into Carry Flag,
            jr    nc, serial2

            in    a,(SIOA_D)
            ld    (ch0in),a         ; save con: 0 data
            ld    e,6               ; flag #6


concmn:     ld    c,flagset         ; set flag for ready
            call  xdos              ; set flag
            jr    intdone

serial2     in    a,(SIOB_D)
            ld    (ch1in),a
            ld    e,7
            jr    concmn
      endif


tickspsec   equ   50

timerint:   di
            push  af
            ld    (savsp),sp        ; save stack ptr
            ld    sp,lstintstk      ; local stack for intr hndl
            ld    (savhl),hl
            push  de
            push  bc
            push  ix
            push  iy
            ld    a,0FFh
            ld    (preemp),a

            ld    a,(tickn)         ; test tickn, indicates delayed processes
            or    a
            jr    z,notickn
            ld    c,flagset
            ld    e,1
            call  xdos              ; set flag #1 each tick

notickn:    ld    hl,cnt1sec
            dec   (hl)
            jr    nz,intdone
            ld    (hl),tickspsec
            ld    c,flagset
            ld    e,2
            call  xdos              ; set flag #2 @ 1 sec

intdone:    xor   a
            ld    (preemp),a        ; clear preempted flag
            pop   iy
            pop   ix
            pop   bc
            pop   de
            ld    sp,(savsp)        ; restore stack ptr
            pop   af
            ld    hl,pdisp          ; MP/M Dispatch -
            push  hl                ; - put on stack for return
            ld    hl,(savhl)        ; restore HL
            reti                    ; clear int and jump to Dispatch

badint:     di
            ld    sp,lstintstk
            ld    a,0FFh
            ld    (preemp),a
            ld    hl,bintm
            call  PutMsg
            di
            halt

bintm:      db    "BadInt",0

; -----------------------------------------------------------------------------
; output ASCII on console 0

PutMsg:     ld    a,(hl)            ; Affects A, C, HL
            and   a
            ret   z                 ; Zero terminates

            push  af
            xor   a
            out   (SIOA_C), a       ; Select RR0
conoutA:    in    a,(SIOA_C)        ; Read UART status register of COM port 1.
            bit   TBMT, a           ; Test TX Data Register Empty ready bit and
            jr    z,conoutA         ; loop until TX buffer is empty.
            pop   af
            out   (SIOA_D), A       ; TX the character.
            inc   hl
            jr    PutMsg

;------------------------------------------------------------------------------
systeminit: di                      ; Disable interrupts

            jp    setup

;==============================================================================

cnt1sec:    db    tickspsec     ; ticks per second counter

timdbg      ds    1                 ; Timer Debuger

intstk:                             ; local interrupt stack
            dw    0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h
            dw    0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h
            dw    0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h
            dw    0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h
lstintstk:
savsp:      ds    2                 ; saved SP during interrupts
savhl:      ds    2                 ; saved HL during interrupt handler
tickn:      db    0                 ; ticking boolean, true = delayed
preemp:     db    0                 ; preempted boolean

userdrv:    ds    1                 ; Boot-drive number

dirbuf:     ds    128               ;scratch directory area

;------------------------------------------------------------------------------
; Cold-boot code, overlayed by disk buffer
; -----------------------------------------------------------------------------
            org   temp
sysorg      equ   0000h

Welcome:    db    CR,LF,"RCBus Banked XIOS for "
      if  mmu612
            db    "Z80 MMU 612"
      else
            db    "Z80 MMU Z2"
      endif
            db    CR,LF,"  v1.02 (C) by T.Pycio 2024",CR,0
SIOtbl:     db    00h, 00011000b    ; WR0 - reset channel
            db    04h, 11000100b    ; WR4 - set clock/64, 1 stop bit, no parity (7372800/64=115200)
      if  quecon
            db    01h, 00011000b    ; WR1 - interrupt on all RX characters
      else
            db    01h, 00000000b    ; WR1 - no interrupts on all Rx characters
      endif
            db    03h, 11000001b    ; WR3 - set Rx enable, 8 bits data
            db    05h, 01101000b    ; WR5 - set Tx enable, 8 bits data, DTR & RTS off
            db    02h, 00h          ; set interrupt vector (channel B only)

; System Initialization. The following registers are input parameters:
; <C>   MP/M debugger restart #
; <DE>  MP/M entry point address for the debugger.
;       Place a jump at the proper debugger restart location to the address
;       contained in <DE>.
; <HL>  BIOS direct jump table address.
;       Place a jump instruction at location 0000H
;       in each bank's base page to the address contained in <HL>
;------------------------------------------------------------------------------

setup:      ld    a,0C3h            ; jump inst.
            ld    (vect*8),a        ; rst vector # * 8
            ld    (sysorg),a        ; at 0: jp <HL>
            ld    (sysorg+1),hl     ; BIOS direct jump table address
            ld    a,c               ; rst vector
            rla
            rla
            rla                     ; * 8
            ld    h,0
            ld    l,a               ; debugger restart address
            ld    (hl),e
            inc   hl
            ld    (hl),d

            xor   a                 ; Cold Start
            ld    (userdrv),a       ; Start from the boot disk (Drive A:, User 0)
            ld    (hstact),a        ; Host Buffer inactive
            ld    (unacnt),a        ; unalloc. ctr. = 0
;
            ld    (timdbg),a        ; Timer Debuger
;
            ld    hl,tpabuf         ; Address of BIOS DMA buffer.
            ld    (dmaadr),hl

; initialize MP/M banks
            ld    hl,0
            ld    de,alv15          ; use the disk15 as storage area
            ld    bc,64             ; copy the first 64 bytes (contains XIOS and
            ldir                    ; BDOS vectors, etc.)
            ld    a, numbnk         ; number of banks
inib2:      push  af
            call  selbank
            ld    hl,alv15
            ld    de,0
            ld    bc,64
            ldir
            pop   af
            dec   a
            jr    nz,inib2
            call  selbank           ; switch bank 0 back in

;  Initialize hardware
            ld    hl, SIOtbl        ; initialize SIO A
            ld    b, 10             ; SIO A uses 5 commands
            ld    c, SIOA_C
            otir

            ld    hl, SIOtbl        ; initialize SIO B
            ld    b, 12             ; SIO B uses 6 commands
            ld    c, SIOB_C
            otir

      if  quecon
            ld    hl,itbl+8
            ld    a,02h             ; WR2
            out   (SIOB_C),a
            ld    a,l               ; Interrupt vector address
            out   (SIOB_C),a
            ld    c,create          ;create process
            ld    de,c0inpd         ;point to process discriptor
            call  xdos
      endif

            ld    hl,Welcome
            push  de
            call  PutMsg            ; Print welcome banner
            pop   de

; init CTC
            ld    a,00110101b       ; Timer: 7372800Hz/256 = 28800Hz
            out   (CTC+1),a         ; Write channel 1's control register
            ld    a,9               ; 28800Hz/9 = 3200Hz
            out   (CTC+1),a         ; Write channel 1's time base

            ld    a,11010101b       ; Counter: 3200Hz
            out   (CTC+2),a         ; Write channel 2's control register
            ld    a,64              ; 3200Hz/64 = 50Hz
            out   (CTC+2),a         ; Write channel 2's time base

; init intettupt
            ld    hl,itbl
            ld    a,l
            out   (CTC),a           ; Set int vector for the CTC
            ld    a,h               ; get page
            ld    i,a               ; Set Z80's int vector table address (hi)
            im    2                 ; Set interrupt mode 2

            ei
            ret

            end
